'use strict';

const AWS = require('aws-sdk'); // eslint-disable-line import/no-extraneous-dependencies
const beeline = require('honeycomb-beeline')({
  writeKey: process.env.HONEYCOMB_API_KEY,
  dataset: process.env.HONEYCOMB_DATASET,
  serviceName: 'lambda'
});

const s3 = new AWS.S3();

// Some far-in-the-future timestamp to subtract against so that we always get
// chronological order of execution timestamp -> reverse lexicographical order.
const END_TIMESTAMP = 2000000000000;

// `persist` will persist a certain text payload to S3
module.exports.persist = (event, context, callback) => {
  let body = event.body || "";

  // This serverless handler happens to expect to be downstream of an existing
  // trace, generated by a Honeycomb Beeline.
  let ctx = beeline.unmarshalTraceContext(event.headers["x-honeycomb-trace"] || "") || {};
  let span = beeline.startTrace({
    name: 'persist',
    content_length: body.length
  }, ctx.traceId, ctx.parentSpanId);

  // This is a dumb way to fake flakiness in this handler, but this enables us
  // to use this serverless function to simulate failures.
  if (body.length > 280) {
    beeline.finishTrace(span);
    callback(null, {
      statusCode: 413,
      body: JSON.stringify({ message: "body too large" }),
    });
    return;
  }

  const key = ""+(END_TIMESTAMP - new Date().getTime());

  let subSpan = beeline.startSpan({
    name: 's3.putObject',
    content_length: body.length
  });
  s3.putObject({
    Body: body,
    Bucket: process.env.bucket,
    Key: key
  }).promise().then(() => {
    if (subSpan) {
      beeline.finishSpan(subSpan);
    }
    let tagSet = [];
    if (body.indexOf("#") > -1) {
      tagSet.push({ Key: "hashtag", Value: "true" });
    }
    if (body.indexOf("@") > -1) {
      tagSet.push({ Key: "username", Value: "true" });
    }
    if (tagSet.length) {
      subSpan = beeline.startSpan({
        name: 's3.putObjectTagging',
        num_tags: tagSet.length,
        keys: tagSet.map(t => t.Key)
      });
      return s3.putObjectTagging({
        // Issuing a second request, because this is a contrived example
        Bucket: process.env.bucket,
        Key: key,
        Tagging: { TagSet: tagSet }
      }).promise();
    }
    return Promise.resolve();
  }).then(() => {
    if (subSpan) {
      beeline.finishSpan(subSpan);
    }
    beeline.finishTrace(span);
    callback(null, {
      statusCode: 200,
      body: JSON.stringify({
        message: `Stored ${body.length} bytes`
      }),
    });
  })
  .catch(err => {
    if (subSpan) {
      beeline.finishSpan(subSpan);
    }
    beeline.finishTrace(span);
    callback(err, { statusCode: 500, body: { message: 'Error persisting' }})
  });
};
